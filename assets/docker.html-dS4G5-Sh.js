import{_ as d,r as l,o as c,c as o,b as e,e as s,w as t,d as a,a as i}from"./app-VitiyI7N.js";const u="/assets/image_vs_contrainer-cNBH-eJg.jpg",p={},h=e("h1",{id:"docker",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker","aria-hidden":"true"},"#"),a(" Docker")],-1),v=i('<li><a href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8">镜像和容器</a><ul><li><a href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB">镜像和容器的区别</a></li><li><a href="#%E9%95%9C%E5%83%8F%E7%90%86%E8%A7%A3">镜像理解</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E7%90%86%E8%A7%A3">容器理解</a></li></ul></li><li><a href="#docker%E5%91%BD%E4%BB%A4">docker命令</a><ul><li><a href="#docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4">docker常见命令</a></li><li><a href="#docker%E5%91%BD%E4%BB%A4%E9%9B%86">docker命令集</a></li></ul></li>',2),m=i('<h1 id="镜像和容器" tabindex="-1"><a class="header-anchor" href="#镜像和容器" aria-hidden="true">#</a> 镜像和容器</h1><h2 id="镜像和容器的区别" tabindex="-1"><a class="header-anchor" href="#镜像和容器的区别" aria-hidden="true">#</a> 镜像和容器的区别</h2><p><img src="'+u+`" alt="image_vs_contrainer"></p><p>两种理解：</p><ul><li><p><strong>光盘操作系统</strong>：简单点说，镜像就类似操作系统光盘介质，容器相当于通过光盘安装后的系统。通过光盘(镜像)，我们能在不同机器上部署系统(容器)，系统内的操作只会保留在当前的系统(容器)中，如果要升级系统，需要使用到光盘，但是可能会导致操作系统的数据丢失。</p></li><li><p><strong>类和对象</strong>：容器是由镜像实例化而来，这和我们学习的面向对象的概念十分相似，我们可以把镜像看作类，把容器看作类实例化后的对象。</p></li></ul><h2 id="镜像理解" tabindex="-1"><a class="header-anchor" href="#镜像理解" aria-hidden="true">#</a> 镜像理解</h2><p>docker的镜像概念类似虚拟机的镜像。是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。（ docker create &lt;image -id &gt; ：为指定的镜像添加一个可读写层，构成一个新的容器；）</p><p>例如：一个镜像可以包含一个完整的ubuntu操作系统环境，里面仅安装了mysql或用户需要的其他应用程序。</p><p>docker镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为UnionFS( Union file system 统一文件系统)，镜像可以基于dockerfile构建，dockerfile是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。</p><p>docker提供了一个很简单的机制来创建镜像或更新现有的镜像。用户甚至可以从其他人那里下载一个已经做好的镜像直接使用。（镜像是只读的，可以理解为静态文件）</p><h2 id="容器理解" tabindex="-1"><a class="header-anchor" href="#容器理解" aria-hidden="true">#</a> 容器理解</h2><p>docker利用容器来运行应用：</p><p>docker容器是由docker镜像创建的运行实例。docker容器类似虚拟机，可以执行包含启动，停止，删除等。</p><p>每个容器间是相互隔离的。</p><p>容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。可以<strong>把容器看作一个简易版的linux环境</strong>（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。</p><p>相对于镜像来说容器是动态的，容器在启动的时候创建了一层可写层次作为最上层。（ docker create &lt;image -id &gt; ：为指定的镜像添加一个可读写层，构成一个新的容器；）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> 容器<span class="token operator">=</span>镜像+可读层
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="docker命令" tabindex="-1"><a class="header-anchor" href="#docker命令" aria-hidden="true">#</a> docker命令</h1><h2 id="docker常见命令" tabindex="-1"><a class="header-anchor" href="#docker常见命令" aria-hidden="true">#</a> docker常见命令</h2><ul><li>新建镜像：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-t</span> image_01.qc:v0.1 /path/to/Dockerfile
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>查看镜像：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> images <span class="token parameter variable">-a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>新建容器：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> create  <span class="token parameter variable">--name</span> myrunoob  nginx:latest 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>查看容器：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>运行容器：</li></ul><p>说明：这个命令是核心命令，可以配置的参数多达28个参数。详细的解释可以通过docker run --help列出。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mynginx <span class="token parameter variable">-d</span> nginx:latest
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /test:/soft centos /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>进入容器退出，并结束容器运行</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">exit</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>退出容器但是容器仍在执行，按<code>ctrl + p + q</code>，会回到宿主机桌面</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ctrl + p + q
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>关闭容器：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">kill</span> e7c  <span class="token comment"># 支持模糊查找，只写名称的前三个就可以</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>重启容器：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> start e7c
<span class="token function">docker</span> restart e7c  <span class="token comment"># 即便容器已经启动，restart也会给重启</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>容器启动并进入后台后，这个时候进入容器进行操作，可以使用docker attach命令或docker exec命令</strong>：</li></ul><p>（1）docker attach 容器id：</p><p>attach是docker自带的命令。<strong>注意</strong>，该命令的前提是，容器是已经被启动的，一旦kill或exit，就先需要start启动容器，否则会报错：<code>You cannot attach to a stopped container, start it first</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> attach e7c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）以交互模式进入容器：</p><p>从Docker的1.3版本起，Docker提供了更加方便的工具exec命令，可以在运行容器内直接执行任意命令。<strong>注意</strong>，该命令的前提是，容器是已经被启动的，一旦kill或exit，就先需要start来启动，然后再执行该命令，不然会报错：<code>Error response from daemon: Container e7c is not running</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> e7c /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker attach命令和docker exec命令的区别：</p><p>（a）当多个窗口同是attach到同一个容器的时候，所有窗口都会同步显示；当某个窗口因命令阻塞时，其他窗口也无法执行操作。（b）可以使用<code>docker exec -it 容器id /bin/bash</code>进入容器并开启一个新的bash终端。 退出容器终端时，不会导致容器的停止。（c）使用<code>docker attach 容器id</code>进入正在执行容器，不会启动新的终端， 退出容器时，会导致容器的停止。</p><ul><li>删除容器：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">rm</span> e7c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>删除镜像：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi image
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="docker命令集" tabindex="-1"><a class="header-anchor" href="#docker命令集" aria-hidden="true">#</a> docker命令集</h2>`,52),b={href:"https://docs.docker.com/engine/reference/commandline/docker/",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.runoob.com/docker/docker-command-manual.html",target:"_blank",rel:"noopener noreferrer"},k=i(`<ul><li>为指定的镜像添加一个可读写层，构成一个新的容器：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> create <span class="token operator">&lt;</span>image -id<span class="token operator">&gt;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>docker start 命令为容器文件系统创建一个进程的隔离空间。注意，每一个容器只能够有一个进行隔离空间；（运行容器）：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> start <span class="token operator">&lt;</span>container -id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>这个是先利用镜像创建一个容器，然后运行了这个容器：</li></ul><p>说明：这个命令是核心命令，可以配置的参数多达28个参数。详细的解释可以通过docker run --help列出。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token operator">&lt;</span>image -id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>停止所用的进程：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> stop <span class="token operator">&lt;</span>container -id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>向所用运行在容器的进行发送一个不友好的sigkill信号：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">kill</span> <span class="token operator">&lt;</span>container -id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>将运行中的进程空间暂停：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker pause &lt;container -id&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>docker rm</code>命令会移除构成容器的可读写层。注意，这个命令<strong>只能对非运行态容器执行</strong>：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">rm</span> <span class="token operator">&lt;</span>container -id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>docker rmi是docker image rm的别名。<code>docker rmi</code>命令会移除构成镜像的一个只读层。你只能够使用<code>docker rmi</code>来移除最顶层（top level layer）（也可以说是镜像），你也可以使用<code>-f</code>参数来强制删除中间的只读层：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker rmi &lt;image -id&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>docker commit</code>命令将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit <span class="token operator">&lt;</span>container-id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>docker save</code>命令会创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令为每一个层都保存了它们的元数据。这个命令只能对镜像生效：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token operator">&lt;</span>image-id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>docker export</code>命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容（注：expoxt后的容器再import到Docker中，通过<code>docker images –tree</code>命令只能看到一个镜像；而save后的镜像则不同，它能够看到这个镜像的历史镜像）：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">export</span> <span class="token operator">&lt;</span>container-id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>docker history</code>命令递归地输出指定镜像的历史镜像：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker history &lt;image-id&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>会列出所有运行中的容器；<code>docker ps -a</code>列出运行中和未运行的容器：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>列出所用的镜像，也可以说列出所用的可读层：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> images <span class="token parameter variable">-a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>显示容器內运行的进程：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker top &lt;container-id&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h1><p>===</p>`,33),f={href:"https://blog.csdn.net/wh211212/article/details/53535881",target:"_blank",rel:"noopener noreferrer"},x={href:"https://blog.csdn.net/wh211212/article/details/53540342",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,"对容器技术写的不错的文章，待看",-1),E={href:"https://bbs.huaweicloud.com/blogs/285728",target:"_blank",rel:"noopener noreferrer"},B=e("p",null,"写了对容器的理解。",-1),A={href:"https://blog.csdn.net/hnmpf/article/details/80924494",target:"_blank",rel:"noopener noreferrer"},y=e("p",null,"深入分析了docker -v的挂载问题。",-1);function C(D,w){const r=l("RouterLink"),n=l("ExternalLinkIcon");return c(),o("div",null,[h,e("ul",null,[e("li",null,[s(r,{to:"/docs/machine-learning/coding/cs-courses/operating-system/operating-system.html"},{default:t(()=>[a("返回上层目录")]),_:1})]),v]),m,e("p",null,[e("a",b,[a("docker官网docker base command line"),s(n)])]),e("p",null,[e("a",g,[a("菜鸟：docker命令大全"),s(n)])]),k,e("ul",null,[e("li",null,[e("a",f,[a("容器技术及其应用白皮书（上）-- 容器技术"),s(n)])]),e("li",null,[e("a",x,[a("容器技术及其应用白皮书（下）-- 容器应用"),s(n)])])]),_,e("ul",null,[e("li",null,[e("a",E,[a("认识容器，我们从它的历史开始聊起"),s(n)])])]),B,e("ul",null,[e("li",null,[e("a",A,[a("docker -v 挂载问题"),s(n)])])]),y])}const q=d(p,[["render",C],["__file","docker.html.vue"]]);export{q as default};
